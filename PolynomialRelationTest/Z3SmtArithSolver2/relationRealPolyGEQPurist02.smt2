(set-logic ALL)
(declare-fun x () Real)
(declare-fun y () Real)
(declare-fun z () Real)
(declare-fun u () Real)
(declare-fun ri () Real)
(echo "Checking if input and output of multiCaseSolveForSubject are equivalent")
(push 1)
(assert (and (or (>= (* x y y y z z u) ri) (and (<= ri 0.0) (= 0.0 u)) (and (< u 0.0) (<= x (/ ri u y y y z z)) (distinct z 0.0) (> y 0.0)) (and (<= ri 0.0) (= 0.0 y)) (and (<= ri 0.0) (= 0.0 z)) (and (<= x (/ ri u y y y z z)) (> u 0.0) (distinct z 0.0) (< y 0.0)) (and (< u 0.0) (>= x (/ ri u y y y z z)) (distinct z 0.0) (< y 0.0)) (and (>= x (/ ri u y y y z z)) (> u 0.0) (distinct z 0.0) (> y 0.0))) (or (not (or (and (<= ri 0.0) (= 0.0 u)) (and (< u 0.0) (<= x (/ ri u y y y z z)) (distinct z 0.0) (> y 0.0)) (and (<= ri 0.0) (= 0.0 y)) (and (<= ri 0.0) (= 0.0 z)) (and (<= x (/ ri u y y y z z)) (> u 0.0) (distinct z 0.0) (< y 0.0)) (and (< u 0.0) (>= x (/ ri u y y y z z)) (distinct z 0.0) (< y 0.0)) (and (>= x (/ ri u y y y z z)) (> u 0.0) (distinct z 0.0) (> y 0.0)))) (not (>= (* x y y y z z u) ri)))))
(check-sat)
(pop 1)
(echo "Checking if input and output of multiCaseSolveForSubject are equivalent")
(push 1)
(assert (and (or (>= (* x y y y z z u) ri) (and (or (= z 0.0) (>= x (/ ri u y y y z z)) (<= u 0.0) (<= y 0.0)) (or (= z 0.0) (>= y 0.0) (>= x (/ ri u y y y z z)) (>= u 0.0)) (or (<= ri 0.0) (not (= 0.0 y))) (or (= z 0.0) (>= y 0.0) (<= x (/ ri u y y y z z)) (<= u 0.0)) (or (= z 0.0) (<= x (/ ri u y y y z z)) (>= u 0.0) (<= y 0.0)) (or (<= ri 0.0) (not (= 0.0 z))) (or (<= ri 0.0) (not (= 0.0 u))))) (or (not (and (or (= z 0.0) (>= x (/ ri u y y y z z)) (<= u 0.0) (<= y 0.0)) (or (= z 0.0) (>= y 0.0) (>= x (/ ri u y y y z z)) (>= u 0.0)) (or (<= ri 0.0) (not (= 0.0 y))) (or (= z 0.0) (>= y 0.0) (<= x (/ ri u y y y z z)) (<= u 0.0)) (or (= z 0.0) (<= x (/ ri u y y y z z)) (>= u 0.0) (<= y 0.0)) (or (<= ri 0.0) (not (= 0.0 z))) (or (<= ri 0.0) (not (= 0.0 u))))) (not (>= (* x y y y z z u) ri)))))
(check-sat)
(pop 1)
(exit)
